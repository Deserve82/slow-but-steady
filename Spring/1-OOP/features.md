# 객체지향의 4대 특성

1. 캡슐화
- 객체의 속성(variable)을 보호하기 위해 사용
- 실제 속성에 직접 접근하는 것이 아니라 제공되는 Method를 통해 속성을 변경
- Method 설계
    - 속성이 선언되었지만 이것의 상태를 변경하는 method가 없다면 잘못 선언된 속성임!
        - 자신이 가지고 있는 속성에 대해서는 해당 상태를 변경하는 기능을 제공해야 함!
    - 실물 객체가 가진 기능을 모두 제공해야 함
    - 각각의 Method는 서로 관련성이 있어야 함
        - ex) 전원의 ON버튼이 있으면 OFF버튼도 존재해야 함
    - 객체 안의 method는 객체 안의 속성을 처리해야 하며, 다른 객체를 전달받아 다른 객체에 정의된 속성을 직접 처리하면 안 됨!
    - 단, method 실행에 필요한 값들은 객체 형태가 아닌 매개변수 형태로 전달되어야 함!
- Method 종류
    1. Getter/Setter Method
        - 외부에서 내부 속성(variable)에 직접 접근하는 것이 아닌 Getter/Setter Method를 통해서 접근하도록 설계
    2. CRUD Method
        - 데이터 처리를 위한 기본적은 CRUD Method 제공
    3. Business Logic Method
        - 비즈니스 로직 처리를 위한 Method 제공
    4. 객체의 생명 주기 처리 Method
        - 흔히 destroy(), disconnect(), quit() 등 소멸에 대한 method 제공
    5. 객체의 영구성 관리 Method
        - 영구성(유효성) 속성에 대한 변경이 필요한 경우, 외부에서는 접근이 불가능하도록 private으로 선언하며, 내부의 다른 Method를 통해서 사용되도록 함
    - Method의 속성은 반드시 1개에 속할 필요는 없으며 여러 속서에 해당 될 수 있음!
- 캡슐화의 장점
    - 추상화 제공
        - 실제로 Method가 어떻게 동작하는지 외부에서 알 필요가 없음
    - 재사용성 향상
        - 객체의 속성과 Method가 모두 캡슐화의 형태로 제공되어 객체의 모듈성과 응집도가 높아짐
        - 객체는 자기 자신의 속성만 변경시키기 때문에 전체적인 프로그래밍에 영향을 끼치지 않음!(절차지향과의 차이-전역변수 사용X)
    - 무결성 제공
        - 캡슐화 코딩에서 주로 **변수는 private**으로 선언하고 **Method는 public**으로 선언 => 무결성 위해
        - Getter/Setter를 제외한 public method는 **입력된 매개변수를 validation한 후 실행**하는 것이 기본임!
            - `validation`을 통해 객체의 값을 바꾸거나 값에 대한 유효성을 가질 수 있음!
            - 해당 method에서 허용하지 않는 범위 내에서 값이 호출되면 무시하거나 에러를 발생시킴으로써 해당 객체의 무결성을 유지함

2. 상속
- 속성의 상속이 아니라 **하위로 내려갈수록 구체화되는 것**을 의미함!
- 상속의 효과
    - 프로그램 이해도 향상
        - 최상위 클래스의 구조를 보고 하위 클래스의 동작을 이해할 수 있음!
    - 재사용성 향상
        - 해당 클래스에 필요한 속성 및 메소드를 모두 정의하지 않고 상속을 받아서 사용!
    - 확장성 향상
        - 일관된 형태의 클래스 객체 추가 가능 (간단한 프로그램 확장 유용)
    - 유지보수성 향상
        - 각 객체마다 자신의 메소드를 정의하고 있다면 많은 코드 수정 작업이 필요하지만 상속을 사용하면 일관된 형태의 코드 작성이 가능함

3. 다형성
- 하나의 개체가 여러 개의 형태로 변화하는 것 의미
- 오버라이딩 사용

4. 추상화
- 객체지향에서의 추상화는 **모델링** 의미
- 공통적인 부분과 개별화된 특성을 분리해서 재조합하는 부분이 추상화임!
- `다형성`, `상속` 모두 추상화에 포함!